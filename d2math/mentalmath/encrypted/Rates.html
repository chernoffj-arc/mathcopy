<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc0857fb9bbda45b61cce4d062c473768e6cd5da0d2a8524a76b1d0ec3a135a9b7e6e4f390f8b8e81270a1b20eb4bc9dda60f20b18f67fa660a1212437533ff30fa38b95af4c40236c3211f553dc6afc7c081585d799f6f3801cf2a73f0bd7eb97c2916034fc6d1d223739fd9818c7fa49e1d0b2c5c1f3bcb74d6770d5e3fde9be123689e4d380bc04f76438968bdd1148193017de1fdf8f8166c8889af69e94a9d4a1ce52d5264d84ba8f57ae9a33a97f621cd36e6cd2cf7da480408dc7005679caf144b41d60e8bde91a79295edaeab4ea47289a64ca19b24c2bb344097d9b4e3d4c5565ed75d3bdf48743f93269b2719eaca5097c7e8a8fb22374b346301d9274ed6fdd2c547c5729f79d6bd1ee29fe122c1c217b07328564a7eff5be77a949b77bb0fd5b97fb52f0fb9b2dea93b56b029b021f4ec768967d75421674d568d5160bdb6f57d307824b77035383dcfc1a32a0aa652863a535b4d79bb0a1f62d96af0636cc95c0c672d30db40808f76884ce3f2a070a0478bfa2a995fa94082e6ddc983e0cc396ec278e2f96786378d8e1929d0ae42a47b64e73ba2b7365b2d331fc342de4cb9cebed4157956a5e2eb5ef535763d5b5af2ae4b41ca2f399d35379738159537bc061c25f73ab676785d1c91f81d76fa9a0cc330508d343c604c731d54e8cab56b74373271014dbc3a796b8b5f71cc1582ab1878ab4db21b0b93fc9f176ed4e51b50a8414b234d148855d957eb2b3f7e173d58007b32e05c1d792c8835b8623ec2357dc4765bb49d083228d1dfd63921a25c3491f21008384a9bfba6be2dda8672762cc4e8d1155ec22602e1b18ab115558b0ab20bf56648dd63e5750d25f1911fbcd007d4f43581b9d478a5c34fe459654bbc9777550887ceb64893fa84e9e045c388fef18c0a796a5d8d2226e18b97f4cde0b29a0bb969ece5ad04e22471fae1544215068e3ed78a83f040a203eee2bfa97bbfadd8bcb7af79caa07550477f84f54a413fe2b46c87d0f2426f5263ca50778e57cfa482f0219ec7a3ae9afd76147c34d31c68a7194fe7f8f0c6ab6833ce32f91f16d760d2a3aa8d4c1b283f391e7311f7c29fc04aeee98d5dd0f23583009b486f411e8ef00772e7e2f6fc5d9763f6e667df17152cd8f4a0d59d08e42347e7fc2f4925de1abc92ea533280bcc7c6965f155466df73854daa9c43a0c4b00388d9cb85503547b8d29d836723c5ba5574140af59d74ecc69778f86c4bb3e2a53a852b12e459d34aa7f269f4110120cb318bebed5aaeb6cadfdfb44999a0ef9efaebb6000ecbd911bc2bd47b83ed461695a4ee46a68768fb2b39048471ce550e2cfcf828215a562eb1b65f8b86e9feb85484d414ea41d6e201f9f1148dc894eff0abb81b226f26d278054f2f454c2743b9ba8d5b0a6d829bedcb59f32912918fef44249323b1bf3493a22522f854da06f6bcecf15d97a577f585ded2e208ff999109062afa3225a50882212202aff595f2a26e31230c41a199e53e7f9faeb924c03dd9ab166ccb94c0638d6fbe5a30de180125f2145e4c3b0ce21a00a28a8db8b3793a2bb9663c2f0c3579a9dbc3e5e01653955a134d286af8e12cc32cc4f6b585a5eeff53a3dddadb805a409659088d964e00e1cb0da29e020d659f8e8a2cd485cd9c2679cd45ef46dd7f0203f76eb500b103a7fbc0d718f67b13a9406cdb69f7f1cc1783d598b7bca5134c350c1260d7447fdb0a6dc5f7a003afb018face89e5200889b545ad01f44ca663b9176db155fdf77cc69bedd55183d591dbd16ca28fa9eada92f82b5472a70bb80f00b5c404720b0e960a3b5fbe56caf6a2faf78a6bb969c1346e13012da5f8f7e770f4b2b96ecfa42a5c1f3d6c83cb1ddc3d1e7ebb1ce683f68bc130fe70e737d5735366c557674d4e6833914f649e6b0ebb25ff89844ba0cbac244e9f2c3e1776bac3a4941295ce67ae774301a1fccad43d9ab884c768cb2bf3a343a1b00616f61457fdd62790b09042451f9c7b8b8db9b6184f175674da51dfab73e45e546b862190c62bbf675766b7994eb177b6d71593203bc93720e293f279e4b867a9175e2c371e3a34888eddcfde1e2e7a0426cb4ad63775a56fd5025186fbe765e37b4eb6b91665a88811bc751e24f910937e3cab0379801135e1644d4a894691fa54190a9dfbdd130d3efae5543a7c68d4e0cbb38aca65d2dce027eceac67dc067f5275b86b86fafdb87f1fb43f48bf6f803a2860c9207a23b938928547d72a501b9d04b05c513697847c89f8eb761e0f12222fdbd8c3147068e641c28b26867b52efa2774c3df078a3da0a7c4695f56f3df7b9ae3cceaa02347adc033869aefe0fc55fb74d042e8a98af061ecf532b92c1b682c0637005ff192c234626d991315224e4520c69835a3b32e5127ee57480726e86fe7b7f66b420fd3056e9d2dc6a0f345887f2450b45ee5df4dc22078dbf82d1368fc42cba37177239cc1431d26d70cb1d7437f759b9b5f983e14b6509eb8198c0418a5d75788d4b8cd15f52f742de8164b2ef636987edea33687922959c4436b45068bb21f04b890128afdd68b87a80274d1fb6984619e2d47410d01c1fb96b828f3db6ec1a0e824017634168bcabda1154807e66022d5fb8f16ba25cec8fdb723c505e93e9f0547227bae794979e288532730cdffec0be2174e787cc51030c52cb67b02250233e2264083e2a53eac7c1f37983f032417d2663d446be7626f3a79369d4b059992424fe294a5755e566efe97201fba9d38b292ad416df175d0d8e5df3369d53f51d3ba79846bd2fec460ed680d838ba8df901cc3590d874f7deb03a733505913c780380c60d75387afbe9f23a86e9885e34d9ebceeb6f746a68ab03e6a9deb4092c747df2171c6e95b5a44014eba1b18819e5135e75b759dbbf931949df6bc3befae86c7f054ad42b3478adb9f4f08979192840fa8ceb839003a58225ca22ecc5e1db124442b38f4f2caff3d3f699fb9d094c1b524e4362dc786d0f6c528db14713b6970cdf932352a78737439bda33e6e90db0d5d368bacedefd534305179d099ffac214bca87838e7fc7f770c26230d8de346b77b94bfede5f54320aab88649522c24a7365d049897a1d289e35f89397510444e5f696f6de9d26aef703f69b906cfdb2d247aa91139ab7d9cebfb740738ca6c03f83b89ed57b21d1da9ec9052f9df0df0b8db178046bdbe3ef34600519456c2028b519524b396b19caa638703e3cc89af41b30066cfb90ae940e1ad8408ed2248e879cfce75892fff7741a8be406b6eec79d2a784255f4bfb16aadc58a716ac466a926d89c56fc4c3459c992511b48fd6b198639cb7e782f93f97ee9c8ea7be98ce7754191b803349d88270fc6cfd1681f754fdcaf26175d61b513ff03640b03da69c53a34aa741b627a0c705f08d293c7e0fa6add5c64c260ad33bb41e271feeff61ec3e6de982f51ffbccd197a7659f591f9b2839b95d127c00874e5772e7ae22ceba4893acd62b68f6bf22025817779c91f29cacf363dba69ee728f2181129ec84a50cedcb863b563cbfb70033b235675356361e50d3dc8de307efc02fb0445b35780e0e235be1cfc7da03792eb86aad6963537635b42554b5d8de48ea88c0ef4411a39207c2c9596fbefc45da3ae0a7e7e298915be50051278a8ae1b3128096739c36643369ebfc5c3737b925de0db6fd412dcea503ea2b2cc2e349988dcba9c0fbea68a0b0704a0eb364ac0a146eb4866d5bed594382440ddc82c98f99c2dcee394706db12c15f549298283af876759017efcfda557673ff9ceb7f4aacd3ad82d88dc6b283d9394b8526b82d76786023ebec24cd55665dc10623a5410f66c837fdeaedd1372754c8ed0cf1e2e6b3c47d1393616d587058b8d2ecc3a5022cf8f3c5743f9cfdcdb3e3d3b6b16ec5acd7d6795bcb022e142dfac0505563effa1ebae7497267bdd62d2a44233fa4405bff29a7d6764b31916d734ecf0aa55fb53ababf803e084621bd3f61efc25b3703e61fd37998aa2d8be74879f4b7bf4cefa3299f3b281d44c760e8cc8458625640f303ad8687fef5be384d5b15abb02ec013ff9685f1c0871fd3521e3501d40c51d0e71723fc2487df12c82f4eb65bad847ce989e3b14d230a30f98ec54f898816f6e8342477603070d626467e04157e4f64ba60d407a6b2bf6b973b6a0704dd6cd538cb77f70191486f234474afaa328857416ba9674adae46a7469d0b2e972d85f611ffbac37d613ca04ea707fbff838231153380b1d87577090bd6743805b26b5fb08bfbb4ce2e107d3db355d90a7d44ddb7a48613c898f39786b0460d66595ea4e9609573ef681d0eac91dfd48acee6ce4a46ad0ac357ef312718018b24b451c76cc8c4be5cceacf7b1fd417ccae3abfa3f800524fb2dd3c8537cc692b6dd3329f77552a472f793f0c8f8836556b21c70f6cb16c963b2e3d5c66c4b0db0352c5680088bd9ad96c9be31e2a242873774e2b70bf97e68736dbf01972f40016994b26e85a9254744f31700016d58eb7e05b9359f4188703f68d90c00b78b5b8c48540e0cedf41133ebbd8a683017c79d6439fa35d3bdbe4a23aa840c4f213836eb198c4db7256569e3b2cd10e3935cc5555ac14233db1dc871cee43e2b90dc493a8e8ebae822f13e859664b4a5ddb34918c03de1d38c2a21b1707d3a45d2a19971516a677fccc75080242700b1ba36e952533a2581aff47e30b167d64c3e5740cbd88c540e3489e9a3044c17f6b60cc200735ac3419853e346cc0678e320442c7fc0daeecac511949abbebfae00824488595dfce9788f91c6b67f6d6edaed3334de7277ede5866d35b1eec4f887d6343060af5b34d03c062711c30d05e339cda10373bfc8a0f8af08ef2bc40c2912a253c26bbb9399475d0d031cb4005a6bf08181b556cb3d5d09a0ece8992dd46afd8e5573a51fd0883531a45eba667da70b71413eca52a19580af8022286884153d90d5473b0cc397345ae5b3c411390c82b4cb93ac8e6e07506fe770f117075bac274f386fff4ce5f9c6e8cfea430fd61572838382a2d8142cf2d4c86f90ae2b3321f7a6f8236de6dbf8a5bbbfaf33c3e6c5074bc38152d5e9637b94d2a9a58f9b730634d44eb0950396ab51c934fc39cc6ea7f9e96eb629476320678bb034881aee7434429918822600dddbffaaf3505457a5a48cfdbb3f0a35d53d38a9691d71d53aa9295e281bf0d88e4f44626b74972aaf57b3235eb04bef09a8672f6c920b214c1e8bbfb1ae341049875a50a2ef76fb73b6f91191e8d2cc4a23538a7207a3120996646901c13cd8e1c9cea38a7e775d060be0cec3fffc580cc94a2734d8f07ae7f7ad96c120d7703ae6c65682a587f7fce1149272e8aa7af53ae93a45c8f512662e4ebff7e0ded2498f66fddb5ce7a449c9a5a7496d477c9db64e1d871233e520c0374ad21e52becb3665c0a6fd2c4f4c3b021261902ac716e4a5a42202398b938dac1431327b8998dd0bff2d968a2553f3fcef33e800e2030f3253df0e11ae6b47d22f609b577a406ceb42b91748ae04670906f83a354421d0df2ea0a93e74c43d2ebe9d52bd6d9a8e8856b3547a93ca65d46750469d204be1116476ca6fec6e93a68e82f5a30c5e3f6ca491e3e19ea46b27989fb70774d0ddd4a4714099953f5e3a6addd596c7ceeea746cabca45532953c0d8ae72de8d6621edc789f76e0e90e71890e97230148c1391f708e63e9246cdc7ed76b8fe85b808f885ad5f05baebb038603fea1d26e7a27416a1e7c7a5824b071de0f7e500cff294be69ae628f49176c214c0a73f24671af4c84ec3c0137da356ad88cb4c7540c6da87348b35efc16ac3bc22e6f595d3daed564c2dddc704dc89388e94fa740a0212c6b1f4417c11252bfa9f887bd2059f4496316f9755580c011c8841a67d36ef49a7186818997f6f7f276fdad3596ddbd1955b6c66dc530501bc2fa0f8714a06c9642282c5e0b7cae7ccf19f665d1f831cc867558fe832681794b9f7a9736a022d12402bc212d19879cd84697e67b36f8a6d6dc70b23d9c5be23d5179c1327a9b5646f43179f05d22059c96c2b5edaf59b47b340baff03c871c4d0191f03eff93196ea6785af30156ac1d3b34bf6cc5b65eebd712ff4d6c05e44da36247d2456eb6a73534a1d722d4521878e53d7e513dc6f82dd2e91c31d9736084ec1cec9e90421f0163d4579edbd40b104f7960e6ab5291a0a23eebe05b0cf4fcbeb7233b0e25705ef9c5c9522feaf7091a24f900302f78c45d5534c8a345d0814adc482d8ef5bf27e82e310387fe107740cb69879fa81d5d658526ca565f5da55881561b761719c4a9c32d0969382897d2e230f6dbdb28d964973fc94f6facdc5940375c67bc5c755070aea8853fe479c6ae602b3e3ea361cfdb785148d78394b654d70011ab655d806d4edf2f27dcfced54aaa21e24a74ab76f407cfd414de52a7c7342ce595dc5d4b5e81a8b99cf1098d419345fabb0bd74410329cbf8d5ae9e5daa6cfa1b8a1dfee598fd5af0c3cb2a4da620ab4ea3cf7a5ab7d355f793a6a28b592c9688ab3f808e4b369532c99257652f7b2dd383f6d6f3476163c7bb4c58fb993efc128d705d914766b84f54f8d16138595a6b7957a8f1064a6daaf49b28cd4918913997d610feaf65d61f2dbe030a181a69d197d9bf7c8a4e9c9d6585036df20e8072cf2247f0eab511af586214c36fda4618a82ef24f07ea95fd6b2efb3bf42e1185e44ce1cdcc927b84b4137c37ff97785681b781d37d6ff8afdbad9612dd0b7ae3e464eb3f2a12dfad4e477ebb1240ab1155dd08ea55ee5c1977895c6a8f925b767b0bd4e2259270625ff2873e77d0eee515923ae2ca83d42e3f289da3fd1467749b1a29988b82d50e65daa9a8dd0152a467b78ee75cdba2853e384c7b6504fb57f2f2e8f16b2a3e73de3b9c7cdb4e57bf972472dd55be14a32adbd9ff64dfcde14349cf363106d4d04582d04cb3e01f775cf35216139d17d7194c6958d3ed329249aa8f37c6421c81c0d6dd0191a1870dbf27700253104586892d0beeba40d8d557f8dd951bb03ff1e404334f9350ae066a97482966f400e396317130b9dc4fac5afb75e1096d508f7c13940f47d163ba50f6e04f9d5e47ddd92454e913c5f261e9bbb4585f6ba7392ef5557fef063843b9ded09b1fcb151af625045a9cafe615e13abb82d7421ed0805cb9535d1e7ed96da43d1d019981274d125a90270f16ef180a1cb74133d7359612c39e565a534441acb85a26ff9bf3ba70c2c962b7b0a324b8826a5639dea271a511a8fa5f1a7be3a88e0027c0a83a0bcd374f84133a233419373b37f64b7870d266a90e4b2b982f6d57a153cce79a5fa03487b66e2a286bc38d7b3bbdc4459371e3d27a9c52c5e07f0a3d17c3b5eb48c825f7273037a403658b334017d2c676d513c2f712ec7da69339ac2e8e066e8e16ebb65483b6a25052e3053eaa8e082c743172a1aa5dd510a73116fbf827e9b9e05b4861d3a722048ff0265655c009b4e680343159baae9981423886b681a39b25c61c986f321ccc706090f4f000e5df2a2b8af461100c2517f78f7dfc65183a2be35a064c1cdc6f7015990c7b50f9bb5d39a759778978ae3e4b2e70fda7e28f22841d1c67fc85c447c1978f9df3180c51cbc733d7afc1c0e511999ad0714c930a00bd007ed03c9d38f8709d76b6dbed6cceeea62c047534bb5c13f308571cedec2648f4086ad89c7ec9dae931b08bfe26bb8bbe65062f3d414cd7ed6250d98fef2598b14a568625e9ea71ee8b3f69639e281d767e42515a80875ffeaade3ce72fec60ffd99805deac3b16548cb8de11dbac84895497308e5f09fadf0ad0f8dcbb85b7a2a5dcbbadf1b7e8a652169d16d219357e8792f8b2b1c7cb2bb005073a4338fdbb2eda83514954804f704b29af911f007f88d6e98da18970211d6421a00cf0dd266da226ce04cfb81346d7f59d7d71cfe3198d065774321f1c2832b82e17bfd62b47557db6d9253940b28b826adcaa331ee81a2b6ac69057144022534576e47440b2f455f0b6adad70ac9ed5b90ce42a9038d6c0666c142f3545f4b3e07729ccb3112d4dd5928760bcebcbd238e5f4b66e0b5f2aa7d4a5f998da89498684f39702f62fadb3b64efb98968a13e33df1134fbd257b584e6244c25faafde054c65a885990ae1e614d69f91064a87bce4541e21ff935c97e7b368c7280ceb0737a8fc35c95cb396cd6f4b0928d342f1b6ec77734a6a66b43f415698afa730051baca08a7771dd06f100ac01acea108883ca35a626078c57c6046ec743af74d0c0033b6f9953b6fd47529f973d2ec922755cb068f78855319ba9cb3fba68f4ff64d6ea42e63214048498916fffda7a404c214b186a05dd4b00119d9232fdf2e5cc22d594da65be42927d8d2f65308c7ca5f467a4aea88adc52487c576a8b9d1240adc8346910ee883f18183487ac4b2748ed338c1ee499825a3939b3dfb4ebc11564eb6308a649821c4637633801ad3ee3b7ab90decdb0ad406458504479324994fa6e45ecbcc59626d3c0d0468ff2cfa74e2303c45fb7d3aa4ec9a9636805e27c056fb2953b68cb1ef0aead073c07ecfc2b3fb6440687753f2804f25ff847a4bbe92a2deaf5da9f643c31e6b7eff0d088319fe3a43d6143de5bfcd1f73c0caa601670bdf62e58be3b0a21c2bc71e2f13f8c8549e9d0a95955bac1d74fd7962752933485fafaee5819af9588d7575ad7942b64003bfb20651ceca1c640600f8a074df912bd1b703d3b8a8d65333c7cbd28d3936fd7fd9af12a4761168da617cad655429ef1dcfeb9e3ec287c48d7637e780b2c5ef29db617b3317b08e04c8741adae1bf1deb5fb9d16370c0c9127744b1fe1773ecb0525d12bcc0d3a10196d921dda1a57f0c7c7ee1dbe5bce778a93f99d62349cea9746c4465c63fa4dfd855ce27c77d0c164bd66a7a01adf892e3aab37c80208fb93d20ed9c0b8577c296136c557d07da0bb342a06ac346b3f0da1050a7e2ebcc0d4af674840914c5a15bfa8f428fb82dbe402575db25a5575ed1635151f4f60ae616b7b051bcb99efd2b6cc10494e42b6ad09f3cb15797d6bc21751638c54626bd752c369fa58b3d2e24ded41e7c651b6a256efc4e3dcce4e75ff9a8da9a4a7596b7528806dfecc6edf11c16e63c0b2387867f6683e39880413a3d0bb4bffc9bbf3d819733aa9895d21ac1d08565a7406d0c22b80dc87a506a6dc13fe9e40f85b6c64388d6b3fcb3b174cb062bfab4af62359218a3a00fdf1e826d7af33618ba25c31567e56a4b05153ac12fbaeccfd2abe45bcd7724ed8efff8a1bb6f1d0c39002b21c56d21e3510a3fe4d3fa97b5f6477c268c278ee8311b2ccf4dc0839ee5e1ea544511a5a76ef6684966d4ce6bccbac53bb296a7f2d0a0a327c3cb955befc798892d4a78f209e563ad411ac9d4708b79b5df35f2d72026b31836000724dd10c07ece9bd175d72705100bd8e389c929f9e051d485b3241dde5a9c51fd92e6e431207169a43fa34eff32786f2013793f2cc9fd88feace046c7486b770a023772d49277ff74e7a0f0c8699a94d2c8e5aafbeb51edae7bbbc1895d9ea6729f49d7b48c03f3fc653bf33d14536dfc8e7001a2e501be76f85641965baf8fa4024d3d4052c7ec2db439016adbaffd1dec83512403de54bb6ffb71e863038b446875c0974cac8b5953c635ead8a3c3b0c9643b80a1a902f1c9a2d564b5c9f40fb1cb0bd383dcd713991ebb0a72d094c8fa220a953a09d1719a9a03ac088a94aa0aed2c9c49939b0d1115c83e1fbec8f799328f22fa9b7026a3539727521ec8acb1ddfda32237b22a796cc831b1cc6778f3985b5bcbe62fde88620ab4896014f2411df084ad843958e2cabb16de2be95e242b32ae0d82367ce4d463ac3032d5fc70771e0cdebc3adaf0349c59919fbb51c7aaa0164426542e9bb5181089d4144e45b383268e4c3b8eceba2606f6a7c9008c563ca42d42ecafa19af0568d943c645269d2b76e77da7778e01830f1696bfdbfcb059d9f0c6ac946474627db4bbee39ef30cfbe08a911922d2529b87bf47cc1c392ab30080eca4fb3a9cb4be9115e097e5aeaf98a157a291f5e7e09f150032a6bd4252b543b0627305b36d2dda8c2c3ad7f162867290143cdcfc415d432bf68e90a25d4242b17122f90f6fbf987e4faa0f92d7a497be28f98c726fc8e34e4d4248d22d5e524b249534330ce7f5e862924ab81d47a4c97cbd1f46b3349bd698d5c7f663cfb40e6d7b52d90c02cc755481b22579ad4802db78c810603d5de12d03f297c957f721a17dfcd73173d586bd34fdb240984aa0cc970b2501429116aabb13466c2b051aa13525ffcb94722aedfe4725539af4fce3dbf947cccc27526fa854a5137a682b94378762ed0662bd9e2782f31191024432efd21d198edab67a7d5b94ce99b00cdda871bb5a052939748dd51c7ea5c35e845f9694281b06f69fb27a36db77d1b9c20d5eba51ba97cb8515e9ba7f1107653fb12dac5100a4e754757fa92063353bcd49722f7da76c2244ba63830a1c4b4a87307fef97134d00a63f63f29fdf2966f05002b6d689b85860b77371c456a1791792f24e5a48ce24189d71f8ad3017cd43885ec9859fe2c2156a364b5d55cb644e3dadf1960537c3d4c7aa014ec53d1794919398b5a46b97b46204e9a5a0143be577c598f59cbefa589121b73ec057041bb932651aa350c42852b1884e3f6a4c494630ea967acaf1ddd68ebebd7a63d1885119c304ae136dddfb24eb2a1177dcca406893eb715263c4d2ba8c9f74038be0f264c4bdde771880dd90bbe90f88da92a5603dcd62f8795a157f6678bdfe04b0e44addc97266ddbf74c26e3592e5bddc7c8b0cb299a1ec11b7346b9ad7616f5d4a00b2b4bdcdc7f7a2e52dee3eb6e6941f8f379a53efa1f8442fb5a06df2757342be96f41297ad8a6b67041190cd051ff6e4e3c0ea5f48a8c635f40e8a680c002a5ec1c491645ee523948ab6c2d0759b23f53bb1b081023f512c3aa7c9b65bbcce26def726b52378c6f9c1f154c8b832e039b3d7edaf1a37e3224c2cf8d8973f88efa06d00bd337c74bee340a8fb22559cb4ccc07c9d9cfe8b8bfaf7ca093f112fa0654086d38dcef9c8eec8f8afd71d07d804fc6b138cd91a20ebc1046fb28bd37883340238c1a5814159118e359b9abb66e7cce872a44fbcd7d656282926de0ea343d1e089644f6901130963d809130c575d3ac6873b783096e6d5713ce3a400b0a9b10b0e0082e1dab00ca0385d60c395bb61364fd3b7c9db94ba6e10e9849fd9e437fcad79716a815dd0c7877d6247ec5258b12d0534ce6d28332106b4dcbcc8213bf2e99df55958507c95a1b39c766064061b47113cc80060498b412a6bbdc2201f9736965db59000e84a5055292f55cc637b43dd7aceb14056a96f87b59d0883c6d01053a36633c1214ed108ad574e74ccb9057baac98ac34471192a7c8be2086a28317e608a6086e99752bd5784f0bf1f2c26d44b9bdefa4e4632a45b0896d43b8277523f29ed6a4d34a3d11f8c09436985920637960fcb6ea52486098d94cfe2b3da7506213ddd645ea43618aa57f5680a71d89ab96ff5c9f45af9744ce450fedfda2d5fd6a0383f43ae6a85ec5ea2f8619bd04c64e20eb8d6aeebd5ed4f41ebc6d82d62a48489392f4269d5d7cf17cd2b1d72a4b09728f7723822eee0ea6ab56e4f717df2746701c61f36df93b9146b05539f64446bf1af4e315850fa47082d1a7984aa6b617e77eb323080c01c2fa41c9fe27a754fe394cea142dc618","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"63b65c6a42d31122e102442f666f73b9"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
